import numpy as np 
import pandas as pd

#ЛИНЕЙНАЯ МОДЕЛЬ 

# №1
np.random.seed(0) # псевдослучайные числа образуют одну и ту же последовательность (при каждом запуске)
x = np.arange(-1.0, 1.0, 0.1) # аргумент [-1; 1] с шагом 0,1
size_train = len(x)  # размер выборки
w = [0.5, -0.3]  # коэффициенты модели
model_a = lambda m_x, m_w: (m_w[1] * m_x + m_w[0])  # модель
loss = lambda ax, y: (ax - y) ** 2 # квадратическая функция потерь
y = model_a(x, w) + np.random.normal(0, 0.1, len(x)) # целевые значения
# предсказания модели
a_x = model_a(x, w)
# считаем потери для каждой точки
losses = loss(a_x, y)
# средний эмпирический риск
Q = np.mean(losses)


# №2
np.random.seed(0) # псевдослучайные числа образуют одну и ту же последовательность (при каждом запуске)
x = np.arange(-1.0, 1.0, 0.1) # аргумент [-1; 1] с шагом 0,1
model_a = lambda xx, ww: (ww[0] + ww[1] * xx) # модель
Y = -5.2 + 0.7 * x + np.random.normal(0, 0.1, len(x)) # вектор целевых значений
matrix_x = np.c_[np.ones_like(x), x] 
w = np.linalg.inv(matrix_x.T @ matrix_x) @ matrix_x.T @ Y


#№3
x_test = [(5, -3), (-3, 8), (3, 6), (0, 0), (5, 3), (-3, -1), (-3, 3)]
w = [-33, 9, 13]
X = np.c_[np.ones(len(x_test)), x_test]
dots = X @ w
# Метки классов
predict = np.sign(dots)

#№4
x_test = [(9, 6), (2, 4), (-3, -1), (3, -2), (-3, 6), (7, -3), (6, 2)]
w = [-14, 7, -5]

X = np.c_[np.ones(len(x_test)), x_test ]
dots = X @ w
predict = np.sign(dots)


#№5
w = np.array([15/7, -9/7, -1])
x_test = np.array([[1, -8, -4], [1, -2, 2], [1, 4, 8], [1, 6, 3]]) # задайте самостоятельно (признаки образов: x0, x1, x2)
y_test = np.array([1,1,-1,-1]) # задайте самостоятельно (метки класса)
margin = []
for i in range(len(x_test)):
    prediction = x_test[i] @ w.T
    margin_value = prediction * y_test[i]
    margin.append(margin_value)


#№6
x_test = np.array([(-5, 2), (-4, 6), (3, 2), (3, -3), (5, 5), (5, 2), (-1, 3)])
y_test = np.array([1, 1, 1, -1, -1, -1, -1])
w = np.array([-8/3, -2/3, 1])

a = lambda x: np.sign(x[0]*w[1] + x[1]*w[2] + w[0])

Q = sum(y_test[i]*a(x_test[i]) < 0 for i in range(len(x_test)))
print(Q)


#№7
def func(x):
    return 0.1 * x**2 - np.sin(x) + 0.1 * np.cos(x * 5) + 1.
# здесь объявляйте дополнительные функции (если необходимо)
w = [1.11,-0.26,0.061,0.0226,0.00178]
coord_x = np.arange(-5.0, 5.0, 0.1) # значения отсчетов по оси абсцисс
coord_y = func(coord_x) # значения функции по оси ординат
sz = len(coord_x) # общее число отсчетов
a = lambda x: w[0] + w[1]*x + w[2]*(x**2)+ w[3]*(x**3)+w[4]*(x**4)
# квадратические потери
losses = (a(coord_x) - coord_y)**2
# средний эмпирический риск Q
Q = np.mean(losses)


#№8 находим веса
data_x = [(5.8, 1.2), (5.6, 1.5), (6.5, 1.5), (6.1, 1.3), (6.4, 1.3), (7.7, 2.0), (6.0, 1.8), (5.6, 1.3), (6.0, 1.6), (5.8, 1.9), (5.7, 2.0), (6.3, 1.5), (6.2, 1.8), (7.7, 2.3), (5.8, 1.2), (6.3, 1.8), (6.0, 1.0), (6.2, 1.3), (5.7, 1.3), (6.3, 1.9), (6.7, 2.5), (5.5, 1.2), (4.9, 1.0), (6.1, 1.4), (6.0, 1.6), (7.2, 2.5), (7.3, 1.8), (6.6, 1.4), (5.6, 2.0), (5.5, 1.0), (6.4, 2.2), (5.6, 1.3), (6.6, 1.3), (6.9, 2.1), (6.8, 2.1), (5.7, 1.3), (7.0, 1.4), (6.1, 1.4), (6.1, 1.8), (6.7, 1.7), (6.0, 1.5), (6.5, 1.8), (6.4, 1.5), (6.9, 1.5), (5.6, 1.3), (6.7, 1.4), (5.8, 1.9), (6.3, 1.3), (6.7, 2.1), (6.2, 2.3), (6.3, 2.4), (6.7, 1.8), (6.4, 2.3), (6.2, 1.5), (6.1, 1.4), (7.1, 2.1), (5.7, 1.0), (6.8, 1.4), (6.8, 2.3), (5.1, 1.1), (4.9, 1.7), (5.9, 1.8), (7.4, 1.9), (6.5, 2.0), (6.7, 1.5), (6.5, 2.0), (5.8, 1.0), (6.4, 2.1), (7.6, 2.1), (5.8, 2.4), (7.7, 2.2), (6.3, 1.5), (5.0, 1.0), (6.3, 1.6), (7.7, 2.3), (6.4, 1.9), (6.5, 2.2), (5.7, 1.2), (6.9, 2.3), (5.7, 1.3), (6.1, 1.2), (5.4, 1.5), (5.2, 1.4), (6.7, 2.3), (7.9, 2.0), (5.6, 1.1), (7.2, 1.8), (5.5, 1.3), (7.2, 1.6), (6.3, 2.5), (6.3, 1.8), (6.7, 2.4), (5.0, 1.0), (6.4, 1.8), (6.9, 2.3), (5.5, 1.3), (5.5, 1.1), (5.9, 1.5), (6.0, 1.5), (5.9, 1.8)]
data_y = [-1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1]

X = np.array(data_x)        # shape (n, 2)
y = np.array(data_y) 
X = np.c_[np.ones(X.shape[0]), X]

w = np.linalg.inv(X.T @ X) @ (X.T @ y)


























































